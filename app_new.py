import streamlit as st
from simulation import run_simulation_with_temporal_learning, run_monte_carlo_analysis, calculate_scenario_probabilities, analyze_risk_metrics
from parameters import parameters, states
from inference import update_prior
from utils import show_parameter_note, show_state_note
import pandas as pd
import altair as alt
import numpy as np

st.set_page_config(page_title="Simulador Bayesiano de Impacto da IA", layout="wide")
st.title("üìä Simulador Bayesiano de Ado√ß√£o de IA com Modelos Causais + Markov")

# Sistema de abas principal
tab1, tab2, tab3 = st.tabs(["üé≤ Simula√ß√£o Monte Carlo", "‚öôÔ∏è Configura√ß√µes", "üìö Benchmarks & Teoria"])

# ==================== ABA 1: SIMULA√á√ÉO MONTE CARLO ====================
with tab1:
    # Sidebar simplificada apenas com controles essenciais
    st.sidebar.header("üéØ Configura√ß√£o da Simula√ß√£o")
    
    n_simulations = st.sidebar.slider(
        "N√∫mero de simula√ß√µes Monte Carlo", 
        100, 2000, 500, step=100,
        help="Mais simula√ß√µes = maior precis√£o, mas tempo maior"
    )
    
    # Cen√°rios alvo para an√°lise
    st.sidebar.subheader("üìä Cen√°rios Alvo")
    st.sidebar.markdown("*Defina os targets de capacidade para an√°lise probabil√≠stica*")
    
    scenario_1 = st.sidebar.number_input(
        "üéØ Cen√°rio Conservador", 
        min_value=2000, 
        max_value=20000, 
        value=2500,
        step=100,
        help="Target conservador - expectativa m√≠nima realista"
    )
    
    scenario_2 = st.sidebar.number_input(
        "üéØ Cen√°rio Moderado", 
        min_value=2000, 
        max_value=20000, 
        value=4000,
        step=100,
        help="Target moderado - expectativa prov√°vel com IA"
    )
    
    scenario_3 = st.sidebar.number_input(
        "üéØ Cen√°rio Otimista", 
        min_value=2000, 
        max_value=20000, 
        value=7000,
        step=100,
        help="Target otimista - m√°ximo potencial com IA avan√ßada"
    )
    
    target_scenarios = [scenario_1, scenario_2, scenario_3]
    
    # Valida√ß√£o dos cen√°rios
    if scenario_1 >= scenario_2 or scenario_2 >= scenario_3:
        st.sidebar.warning("‚ö†Ô∏è Os cen√°rios devem estar em ordem crescente: Conservador < Moderado < Otimista")
    
    # Bot√£o para executar simula√ß√£o
    run_simulation = st.sidebar.button(
        "üöÄ Executar Simula√ß√£o Monte Carlo",
        type="primary",
        help="Executa an√°lise probabil√≠stica completa com m√∫ltiplas simula√ß√µes estoc√°sticas"
    )
    
    # Obt√©m configura√ß√µes das outras abas (session state)
    if "n_gerentes" not in st.session_state:
        st.session_state.n_gerentes = 27000
    if "n_meses" not in st.session_state:
        st.session_state.n_meses = 36
    if "learning_enabled" not in st.session_state:
        st.session_state.learning_enabled = True
    if "custom_matrix" not in st.session_state:
        st.session_state.custom_matrix = [
            [0.60, 0.35, 0.05, 0.00, 0.00],
            [0.00, 0.65, 0.30, 0.05, 0.00],
            [0.00, 0.00, 0.70, 0.25, 0.05],
            [0.00, 0.00, 0.00, 0.80, 0.20],
            [0.00, 0.00, 0.00, 0.00, 1.00]
        ]
    
    # ===== CONTE√öDO PRINCIPAL DA ABA SIMULA√á√ÉO =====
    
    # Explica√ß√£o da Matriz de Alta Volatilidade (movida do sidebar)
    st.markdown("## üö® Modelo de Alta Volatilidade para IA")
    
    with st.expander("üìö Fundamenta√ß√£o Te√≥rica da Matriz de Transi√ß√£o v3.1", expanded=True):
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown("""
            ### **1. üîÑ DISRUP√á√ÉO TECNOL√ìGICA**
            **Base:** Clayton Christensen - "Innovator's Dilemma"
            
            - **Princ√≠pio:** Tecnologias disruptivas n√£o seguem progress√£o linear
            - **Implementa√ß√£o:** "Saltos" poss√≠veis (S0‚ÜíS2: 5%)
            - **Justificativa:** IA pode transformar processos instantaneamente
            - **Evid√™ncia:** Casos reais de ado√ß√£o acelerada (ChatGPT, Copilot)
            
            ### **2. üåê NETWORK EFFECTS**
            **Base:** Metcalfe's Law aplicado √† ado√ß√£o organizacional
            
            - **Princ√≠pio:** Valor cresce exponencialmente com ado√ß√£o
            - **Implementa√ß√£o:** Efeito viral quando IA "pega" na organiza√ß√£o  
            - **Resultado:** Acelera√ß√£o exponencial vs. fracasso total
            - **Transi√ß√µes:** 25-35% vs. 10-15% em modelos tradicionais
            """)
        
        with col2:
            st.markdown("""
            ### **3. üìà TIPPING POINT THEORY**
            **Base:** Malcolm Gladwell - "Ponto de Virada"
            
            - **Princ√≠pio:** Mudan√ßas graduais ‚Üí transforma√ß√£o s√∫bita
            - **Implementa√ß√£o:** 20-25% transi√ß√µes vs. 10-15% anteriores
            - **Gatilho:** Massa cr√≠tica de adotantes iniciais
            - **Evid√™ncia:** Curva S de ado√ß√£o tecnol√≥gica
            
            ### **4. ‚ö° ORGANIZATIONAL HETEROGENEITY (v3.1)**
            **Base:** Nelson & Winter - Teoria Evolutiva da Mudan√ßa
            
            - **DNA Organizacional:** 6 dimens√µes de heterogeneidade
            - **Regime Switching:** 3 regimes econ√¥micos distintos
            - **Matrix Customization:** Cada organiza√ß√£o tem matriz √∫nica
            - **Fat Tails:** P1-P99 tracking para capturar extremos
            """)
        
        # Tabela comparativa
        st.markdown("### üìä Evolu√ß√£o do Modelo: v2.0 ‚Üí v3.0 ‚Üí v3.1")
        
        comparison_data = {
            "Aspecto": ["Par√¢metros", "Market Shocks", "Heterogeneidade", "Regime Switching", "Tail Analysis"],
            "v2.0 (Conservador)": ["Beta(5,3) std~17%", "Raros (5%)", "Uniform agents", "Single regime", "P5-P95"],
            "v3.0 (Alta Incerteza)": ["Beta(1.2,1.8) std~28%", "Frequentes (25%)", "Uniform agents", "Single regime", "P5-P95"],
            "v3.1 (Ultimate)": ["Beta(1.2,1.8) std~28%", "Regime-dependent", "6D DNA per org", "3 regimes", "P1-P99"],
            "Impacto": ["2x variance", "5x frequency", "Organizational realism", "Structural breaks", "Fat tail capture"]
        }
        
        st.dataframe(pd.DataFrame(comparison_data), use_container_width=True)
    
    # Estado atual das configura√ß√µes
    st.markdown("### ‚öôÔ∏è Configura√ß√µes Atuais")
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric("üë• Gerentes", f"{st.session_state.n_gerentes:,}")
    with col2:
        st.metric("üìÖ Horizonte", f"{st.session_state.n_meses} meses")
    with col3:
        st.metric("üß† Aprendizado", "Ativo" if st.session_state.learning_enabled else "Inativo")
    with col4:
        st.metric("üé≤ Simula√ß√µes", f"{n_simulations}")
    
    # Execu√ß√£o da simula√ß√£o Monte Carlo
    if run_simulation:
        st.markdown("---")
        st.subheader("üé≤ An√°lise Probabil√≠stica Monte Carlo v3.1")
        
        # Progress bar para simula√ß√µes
        with st.spinner(f'Executando {n_simulations} simula√ß√µes estoc√°sticas com M√ÅXIMA VOLATILIDADE...'):
            monte_carlo_results = run_monte_carlo_analysis(
                n_gerentes=st.session_state.n_gerentes,
                n_months=st.session_state.n_meses,
                transition_matrix=st.session_state.custom_matrix,
                learning_enabled=st.session_state.learning_enabled,
                n_simulations=n_simulations
            )
        
        # An√°lise de riscos
        baseline = 2000  # Capacidade sem IA
        risk_metrics = analyze_risk_metrics(monte_carlo_results, baseline=baseline)
        
        # Calcula probabilidades dos cen√°rios
        scenario_probs = calculate_scenario_probabilities(monte_carlo_results, target_scenarios)
        
        # === RESULTADOS v3.1 ===
        
        # 1. M√©tricas de Volatilidade
        st.subheader("üå™Ô∏è An√°lise de Volatilidade v3.1")
        
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            cv = monte_carlo_results.get("volatility_metrics", {}).get("coefficient_of_variation", risk_metrics['coefficient_variation'])
            st.metric(
                "üìä Coef. Varia√ß√£o", 
                f"{cv:.1%}",
                help="Volatilidade relativa - quanto maior, mais incerteza"
            )
        
        with col2:
            tail_ratio = monte_carlo_results.get("volatility_metrics", {}).get("tail_ratio", 0)
            st.metric(
                "üéØ Tail Ratio", 
                f"{tail_ratio:.2f}",
                help="(P95-P5)/Mean - captura dispers√£o das caudas"
            )
        
        with col3:
            extreme_range = monte_carlo_results.get("volatility_metrics", {}).get("extreme_range", 0)
            st.metric(
                "üìè Range Extremo", 
                f"{extreme_range:.0f}",
                help="Max - Min: amplitude total dos resultados"
            )
        
        with col4:
            iqr = monte_carlo_results["final_stats"].get("iqr", 0)
            st.metric(
                "üì¶ IQR", 
                f"{iqr:.0f}",
                help="P75-P25: dispers√£o do n√∫cleo da distribui√ß√£o"
            )
        
        # 2. An√°lise de Regimes (se dispon√≠vel)
        if "regime_analysis" in monte_carlo_results:
            st.subheader("üîÑ An√°lise de Regimes Econ√¥micos")
            
            regime_dist = monte_carlo_results["regime_analysis"]["regime_distribution"]
            
            col1, col2, col3 = st.columns(3)
            
            with col1:
                st.metric(
                    "üêå Conservative",
                    f"{regime_dist.get('conservative', 0):.1%}",
                    help="Organiza√ß√µes em regime conservador"
                )
            
            with col2:
                st.metric(
                    "‚öñÔ∏è Normal", 
                    f"{regime_dist.get('normal', 0):.1%}",
                    help="Organiza√ß√µes em regime normal"
                )
            
            with col3:
                st.metric(
                    "üöÄ Aggressive",
                    f"{regime_dist.get('aggressive', 0):.1%}",
                    help="Organiza√ß√µes em regime agressivo"
                )
        
        # 3. Gr√°fico com intervalos de confian√ßa EXTREMOS
        st.subheader("üìà Proje√ß√£o com Intervalos de Confian√ßa v3.1")
        
        monthly_data = pd.DataFrame({
            'M√™s': range(st.session_state.n_meses),
            'P1': monte_carlo_results["monthly_percentiles"].get("p1", [0]*st.session_state.n_meses),
            'P5': monte_carlo_results["monthly_percentiles"]["p5"],
            'P25': monte_carlo_results["monthly_percentiles"]["p25"], 
            'Mediana': monte_carlo_results["monthly_percentiles"]["p50"],
            'P75': monte_carlo_results["monthly_percentiles"]["p75"],
            'P95': monte_carlo_results["monthly_percentiles"]["p95"],
            'P99': monte_carlo_results["monthly_percentiles"].get("p99", [0]*st.session_state.n_meses)
        })
        
        # Gr√°fico com bandas extremas
        base_chart = alt.Chart(monthly_data).add_params(
            alt.selection_interval(bind='scales')
        )
        
        # Banda 98% (P1-P99) - EXTREMOS
        if "p1" in monte_carlo_results["monthly_percentiles"]:
            area_98 = base_chart.mark_area(
                opacity=0.1, color='purple'
            ).encode(
                x='M√™s:Q',
                y='P1:Q',
                y2='P99:Q'
            )
        else:
            area_98 = alt.Chart()
        
        # Banda 90% (P5-P95)
        area_90 = base_chart.mark_area(
            opacity=0.2, color='blue'
        ).encode(
            x='M√™s:Q',
            y='P5:Q',
            y2='P95:Q'
        )
        
        # Banda 50% (P25-P75)  
        area_50 = base_chart.mark_area(
            opacity=0.4, color='blue'
        ).encode(
            x='M√™s:Q',
            y='P25:Q', 
            y2='P75:Q'
        )
        
        # Linha da mediana
        median_line = base_chart.mark_line(
            color='red', strokeWidth=3
        ).encode(
            x='M√™s:Q',
            y='Mediana:Q'
        )
        
        confidence_chart = (area_98 + area_90 + area_50 + median_line).resolve_scale(
            y='independent'
        ).properties(
            width=800, height=400,
            title="Proje√ß√£o v3.1: Intervalos de Confian√ßa EXTREMOS (98%, 90%, 50%)"
        )
        
        st.altair_chart(confidence_chart, use_container_width=True)
        
        # 4. M√©tricas de Cen√°rios
        st.subheader("üéØ Probabilidade dos Cen√°rios")
        
        col1, col2, col3 = st.columns(3)
        
        scenarios = ["Conservador", "Moderado", "Otimista"]
        for i, (col, scenario_name, target) in enumerate(zip([col1, col2, col3], scenarios, target_scenarios)):
            with col:
                prob_exceed = scenario_probs[f"P(>= {target})"]
                prob_within = scenario_probs[f"P(¬±5% de {target})"]
                
                st.metric(
                    f"üéØ {scenario_name} ({target})",
                    f"{prob_exceed:.1%}",
                    help=f"Probabilidade de atingir ou superar {target} contas/gerente"
                )
                st.write(f"üìç Precis√£o ¬±5%: {prob_within:.1%}")
        
        # 5. Distribui√ß√£o final com FAT TAILS
        st.subheader("üìä Distribui√ß√£o Final com Fat Tails")
        
        hist_data = pd.DataFrame({
            'Capacidade Final': monte_carlo_results["final_capacities"]
        })
        
        histogram = alt.Chart(hist_data).mark_bar(
            opacity=0.7
        ).encode(
            x=alt.X('Capacidade Final:Q', bin=alt.Bin(maxbins=40), title='Contas por Gerente'),
            y=alt.Y('count()', title='Frequ√™ncia'),
            color=alt.value('steelblue')
        ).properties(
            width=800, height=350,
            title=f'Distribui√ß√£o v3.1: Fat Tails e Extremos ({n_simulations} simula√ß√µes)'
        )
        
        # Adiciona linhas para percentis extremos
        extreme_lines = []
        percentiles = [1, 5, 25, 50, 75, 95, 99]
        colors = ['purple', 'red', 'orange', 'black', 'orange', 'red', 'purple']
        
        for p, color in zip(percentiles, colors):
            if f"p{p}" in monte_carlo_results["final_stats"]:
                value = monte_carlo_results["final_stats"][f"p{p}"]
                line = alt.Chart(pd.DataFrame({'value': [value], 'label': [f'P{p}']})).mark_rule(
                    color=color, strokeWidth=1, strokeDash=[3,3]
                ).encode(x='value:Q')
                extreme_lines.append(line)
        
        final_chart = histogram
        for line in extreme_lines:
            final_chart += line
        
        st.altair_chart(final_chart, use_container_width=True)
        
        # 6. Interpreta√ß√£o v3.1
        st.subheader("üíº Interpreta√ß√£o Executiva v3.1")
        
        mean_final = monte_carlo_results["final_stats"]["mean"]
        std_final = monte_carlo_results["final_stats"]["std"]
        p1_final = monte_carlo_results["final_stats"].get("p1", 0)
        p99_final = monte_carlo_results["final_stats"].get("p99", 0)
        
        st.info(f"""
        **üéØ Resultado Central:** {mean_final:.0f} ¬± {std_final:.0f} contas/gerente
        
        **üìä Extremos Capturados:**
        - **Cen√°rio Catastr√≥fico (P1):** {p1_final:.0f} contas
        - **Cen√°rio Excepcional (P99):** {p99_final:.0f} contas
        
        **üå™Ô∏è Volatilidade Real√≠stica:**
        - **Coeficiente Varia√ß√£o:** {cv:.1%} (vs. ~15% modelos tradicionais)
        - **Range de Incerteza:** {extreme_range:.0f} contas (amplitude total)
        
        **üî¨ Valida√ß√£o Cient√≠fica:**
        - ‚úÖ Fat tails capturadas (P1-P99 tracking)
        - ‚úÖ Organizational heterogeneity implementada
        - ‚úÖ Regime switching ativo
        - ‚úÖ Volatilidade condizente com literatura IA
        """)
        
        # Alerta sobre volatilidade
        if cv > 0.50:  # Se CV > 50%
            st.warning("""
            ‚ö†Ô∏è **ALTA VOLATILIDADE DETECTADA**
            
            O modelo est√° capturando a EXTREMA incerteza inerente √† ado√ß√£o de IA organizacional.
            Esta volatilidade √© **REAL√çSTICA** e reflete:
            - Heterogeneidade organizacional real
            - Natureza disruptiva da IA
            - Regime switching econ√¥mico
            - Fat tail distributions naturais em inova√ß√£o
            
            **Recomenda√ß√£o:** Use m√∫ltiplos cen√°rios para tomada de decis√£o.
            """)
        
    else:
        # Estado inicial
        st.info(f"""
        ### üëÜ Clique em "üöÄ Executar Simula√ß√£o Monte Carlo" na barra lateral
        
        **üÜï NOVIDADES v3.1:**
        - ‚úÖ Organizational heterogeneity (6 dimens√µes de DNA)
        - ‚úÖ Regime switching (3 regimes econ√¥micos)
        - ‚úÖ Fat tail analysis (P1-P99 tracking)
        - ‚úÖ Matrix customization per organization
        - ‚úÖ Maximum entropy approach
        
        **‚è±Ô∏è Tempo estimado:** {n_simulations // 100} a {n_simulations // 50} segundos
        """)

# ==================== ABA 2: CONFIGURA√á√ïES ====================
with tab2:
    st.header("‚öôÔ∏è Configura√ß√µes Avan√ßadas do Modelo")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("üéõÔ∏è Par√¢metros B√°sicos")
        
        n_gerentes = st.slider("üë• N√∫mero de gerentes", 1000, 50000, st.session_state.n_gerentes, step=1000)
        st.session_state.n_gerentes = n_gerentes
        
        n_meses = st.slider("üìÖ Horizonte (meses)", 6, 60, st.session_state.n_meses)
        st.session_state.n_meses = n_meses
        
        learning_enabled = st.checkbox(
            "üß† Aprendizado Temporal Bayesiano", 
            value=st.session_state.learning_enabled,
            help="Se habilitado, os posteriores de cada m√™s se tornam priors do pr√≥ximo m√™s"
        )
        st.session_state.learning_enabled = learning_enabled
        
        st.subheader("üß™ Atualiza√ß√£o Manual dos Priors")
        
        prior_name = st.selectbox("Par√¢metro", list(parameters.keys()))
        successes = st.number_input("Sucessos observados", 0, 1000, 20)
        trials = st.number_input("Total de experimentos", 1, 1000, 30)
        
        if st.button("Atualizar Prior"):
            updated = update_prior(prior_name, successes, trials)
            parameters[prior_name]["alpha"] = updated["new_alpha"]
            parameters[prior_name]["beta"] = updated["new_beta"]
            st.success(f"Prior atualizado: Beta({updated['new_alpha']}, {updated['new_beta']})")
    
    with col2:
        st.subheader("üîÑ Matriz de Transi√ß√£o Personalizada")
        
        # NOVA MATRIZ: Mais vol√°til para refletir natureza disruptiva da IA
        default_matrix = [
            [0.60, 0.35, 0.05, 0.00, 0.00],  # S0: Possibilidade de "saltos"
            [0.00, 0.65, 0.30, 0.05, 0.00],  # S1: Mais progress√£o r√°pida
            [0.00, 0.00, 0.70, 0.25, 0.05],  # S2: Acelera√ß√£o poss√≠vel  
            [0.00, 0.00, 0.00, 0.80, 0.20],  # S3: Transforma√ß√£o mais r√°pida
            [0.00, 0.00, 0.00, 0.00, 1.00]   # S4: Estado absorvente
        ]
        
        if st.button("üîÅ Resetar para benchmark v3.1"):
            st.session_state.custom_matrix = default_matrix
            st.success("Matriz resetada para benchmark v3.1!")
        
        # Interface para edi√ß√£o da matriz
        if "custom_matrix" not in st.session_state:
            st.session_state.custom_matrix = default_matrix
        
        st.markdown("**Edite as probabilidades de transi√ß√£o:**")
        
        for i, state in enumerate(states):
            st.markdown(f"**{state['nome']} ‚Üí ...**")
            cols = st.columns(5)
            row_sum = 0
            new_row = []
            
            for j in range(len(states)):
                with cols[j]:
                    if i > j:
                        st.text_input(f"‚Üí {states[j]['nome'][:3]}", "0.00", disabled=True, key=f"disabled_{i}_{j}")
                        new_row.append(0.0)
                    else:
                        val = st.number_input(
                            f"‚Üí {states[j]['nome'][:3]}", 
                            0.0, 1.0, 
                            st.session_state.custom_matrix[i][j],
                            0.01, 
                            key=f"matrix_{i}_{j}",
                            help="Probabilidade mensal de transi√ß√£o"
                        )
                        new_row.append(val)
            
            # Normaliza a linha
            row_sum = sum(new_row)
            if row_sum > 0:
                new_row = [p / row_sum for p in new_row]
            
            st.session_state.custom_matrix[i] = new_row
        
        # Mostra matriz atual
        st.markdown("**Matriz Atual:**")
        matrix_df = pd.DataFrame(
            st.session_state.custom_matrix,
            columns=[f"{s['nome'][:10]}" for s in states],
            index=[f"{s['nome'][:10]}" for s in states]
        )
        st.dataframe(matrix_df.style.format("{:.2f}"), use_container_width=True)

# ==================== ABA 3: BENCHMARKS & TEORIA ====================
with tab3:
    st.header("üìö Benchmarks Cient√≠ficos & Fundamenta√ß√£o Te√≥rica")
    
    # Par√¢metros Bayesianos
    st.subheader("üéØ Par√¢metros do Modelo Bayesiano v3.1")
    
    for name, param in parameters.items():
        with st.expander(f"üìä {name.replace('_', ' ')}", expanded=False):
            show_parameter_note(name, param)
    
    st.markdown("---")
    
    # Estados de Ado√ß√£o
    st.subheader("üîÑ Estados de Ado√ß√£o (Markov)")
    
    for state in states:
        with st.expander(f"üìà {state['nome']}", expanded=False):
            show_state_note(state)
    
    st.markdown("---")
    
    # Metodologia
    st.subheader("üî¨ Metodologia Cient√≠fica v3.1")
    
    methodology_tabs = st.tabs(["üé≤ Monte Carlo", "üß† Bayesiano", "üîÑ Markov", "üå™Ô∏è Volatilidade v3.1", "üìà Integra√ß√£o"])
    
    with methodology_tabs[0]:
        st.markdown("""
        ### üé≤ Simula√ß√£o Monte Carlo
        
        **üìö Base Te√≥rica:** M√©todo de Monte Carlo (Metropolis & Ulam, 1949)
        
        **üéØ Implementa√ß√£o v3.1:**
        - **N simula√ß√µes independentes** (100-2000 configur√°vel)
        - **Organizational heterogeneity** (6D DNA por organiza√ß√£o)
        - **Regime switching** (3 regimes econ√¥micos por simula√ß√£o)
        - **Fat tail tracking** (P1-P99 percentiles)
        
        **‚úÖ Vantagens:**
        - Captura **incerteza real** do modelo
        - **An√°lise de riscos** quantitativa extrema
        - **Intervalos de confian√ßa** estatisticamente robustos
        - **Cen√°rios extremos** naturalmente inclu√≠dos
        
        **üìä Output v3.1:**
        - Distribui√ß√£o com fat tails
        - Percentis extremos (P1, P5, P10, ..., P90, P95, P99)
        - An√°lise de regimes econ√¥micos
        - M√©tricas de volatilidade avan√ßadas
        """)
    
    with methodology_tabs[1]:
        st.markdown("""
        ### üß† Infer√™ncia Bayesiana Extrema
        
        **üìö Base Te√≥rica:** Maximum Entropy + Conjugate Priors
        
        **üéØ Par√¢metros v3.1 (ALTA INCERTEZA):**
        ```python
        expertise_acquisition = Beta(1.2, 1.8)  # std ~28% vs. 17% anterior
        change_management = Beta(1.0, 2.0)      # std ~33% vs. 18% anterior  
        technology_readiness = Beta(1.5, 1.5)   # std ~25% vs. 17% anterior
        ```
        
        **üîÑ Aprendizado Temporal Inst√°vel:**
        - Cada m√™s: posterior ‚Üí prior (inst√°vel)
        - Learning noise: ¬±15% varia√ß√£o
        - Temporal breaks: regime switching
        
        **‚úÖ Justificativa Cient√≠fica:**
        - **Maximum entropy principle:** maximize incerteza quando informa√ß√£o limitada
        - **IA reality:** expertise paradox + 70% change failure rate
        - **Fat tail priors:** Beta com baixo Œ±+Œ≤ ‚Üí high variance
        """)
    
    with methodology_tabs[2]:
        st.markdown("""
        ### üîÑ Cadeias de Markov Disruptivas
        
        **üìö Base Te√≥rica:** Punctuated Equilibrium + Network Effects
        
        **üéØ Estados & Multiplicadores:**
        - **S0:** N√£o usa IA (1.0x) ‚Üí baseline
        - **S1:** Teste inicial (1.2x) ‚Üí +20% capacidade
        - **S2:** Ado√ß√£o parcial (1.6x) ‚Üí +60% capacidade
        - **S3:** Ado√ß√£o completa (2.0x) ‚Üí +100% capacidade
        - **S4:** Otimiza√ß√£o radical (3.5x) ‚Üí +250% capacidade
        
        **üöÄ Matriz v3.1 (ALTA VOLATILIDADE):**
        ```
        [0.60, 0.35, 0.05, 0.00, 0.00]  # Saltos poss√≠veis!
        [0.00, 0.65, 0.30, 0.05, 0.00]  # Acelera√ß√£o 35%
        [0.00, 0.00, 0.70, 0.25, 0.05]  # Progress√£o 30%
        [0.00, 0.00, 0.00, 0.80, 0.20]  # Transforma√ß√£o 20%
        [0.00, 0.00, 0.00, 0.00, 1.00]  # Estado absorvente
        ```
        
        **‚ö° Propriedades Inovadoras:**
        - **Saltos permitidos:** S0‚ÜíS2 (5% chance)
        - **Irreversibilidade:** Aprendizado permanente
        - **Customiza√ß√£o:** Matrix √∫nica por organiza√ß√£o
        """)
    
    with methodology_tabs[3]:
        st.markdown("""
        ### üå™Ô∏è Sistema de Volatilidade v3.1
        
        **üèóÔ∏è ARQUITETURA DE M√ÅXIMA INCERTEZA:**
        
        **1. üß¨ ORGANIZATIONAL DNA (6 Dimens√µes)**
        ```python
        dna = {
            'risk_culture': Beta(1.0, 2.5),     # Maioria risk-averse
            'tech_readiness': Beta(1.5, 1.5),   # Bimodal distribution
            'resource_capacity': Beta(1.2, 1.8), # Few resource-rich
            'leadership_vision': Beta(2.0, 1.0), # Some visionary
            'regulatory_pressure': Beta(1.8, 1.2), # Sector dependent
            'network_position': Beta(1.3, 1.7)   # Network centrality
        }
        ```
        
        **2. üîÑ REGIME SWITCHING (3 Regimes)**
        ```python
        regimes = {
            'conservative': {shock_multiplier: 0.6, bias: -0.10},
            'normal': {shock_multiplier: 1.0, bias: 0.0},
            'aggressive': {shock_multiplier: 1.7, bias: +0.15}
        }
        ```
        
        **3. ‚ö° MARKET SHOCKS EXTREMOS**
        - **Frequ√™ncia:** 25% por m√™s (vs. 5% tradicional)
        - **Intensidade:** ¬±80% (vs. ¬±20% tradicional)  
        - **Tipos:** 7 tipos distintos (regulatory, breakthrough, etc.)
        
        **4. üìä FAT TAIL ANALYSIS**
        - **Percentis extremos:** P1, P5, P10, ..., P90, P95, P99
        - **Tail metrics:** tail_ratio, extreme_range, tail_thickness
        - **Distribution:** Heavy-tailed, n√£o Gaussiana
        """)
    
    with methodology_tabs[4]:
        st.markdown("""
        ### üìà Integra√ß√£o Cient√≠fica v3.1
        
        **üîÑ FLUXO INTEGRADO AVAN√áADO:**
        ```
        Para cada simula√ß√£o i:
        ‚îú‚îÄ‚îÄ 1. Sample Organizational DNA (6D)
        ‚îú‚îÄ‚îÄ 2. Sample Economic Regime (3 types) 
        ‚îú‚îÄ‚îÄ 3. Customize Transition Matrix (DNA + regime)
        ‚îî‚îÄ‚îÄ Para cada m√™s t:
            ‚îú‚îÄ‚îÄ 4. Sample Bayesian Parameters Beta(Œ±,Œ≤)
            ‚îú‚îÄ‚îÄ 5. Apply Bayesian Factors (0.3x - 3.0x)
            ‚îú‚îÄ‚îÄ 6. Apply Market Shocks (25% prob)
            ‚îú‚îÄ‚îÄ 7. Add Individual Variability
            ‚îú‚îÄ‚îÄ 8. Simulate Individual Transitions
            ‚îú‚îÄ‚îÄ 9. Apply Regime-specific Noise
            ‚îî‚îÄ‚îÄ 10. Update Posteriors (learning)
        ```
        
        **üéØ INOVA√á√ïES CIENT√çFICAS:**
        
        **v1.0:** Markov determin√≠stico b√°sico
        **v2.0:** + Aprendizado temporal bayesiano
        **v3.0:** + Alta volatilidade para IA
        **v3.1:** + Organizational heterogeneity + Regime switching + Fat tails
        
        **üìä VALIDA√á√ÉO:**
        - ‚úÖ **Literature consistency:** Par√¢metros baseados em benchmarks
        - ‚úÖ **Empirical evidence:** Volatilidade condizente com casos reais
        - ‚úÖ **Statistical robustness:** Fat tails + extreme percentiles
        - ‚úÖ **Organizational realism:** Heterogeneity + regime dynamics
        
        **üöÄ RESULTADO:**
        - **Realismo m√°ximo:** Captura complexidade real da IA organizacional
        - **Extremos inclu√≠dos:** P1-P99 para cen√°rios raros mas poss√≠veis
        - **Decis√£o informada:** M√∫ltiplos cen√°rios + an√°lise de riscos
        - **Aplicabilidade executiva:** Recomenda√ß√µes baseadas em probabilidades
        """)
